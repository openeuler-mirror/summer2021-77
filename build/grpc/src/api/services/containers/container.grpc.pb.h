// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: container.proto
// Original file comments:
// #######################################################################
// ##- @Copyright (C) Huawei Technologies., Ltd. 2019. All rights reserved.
// # - iSulad licensed under the Mulan PSL v2.
// # - You can use this software according to the terms and conditions of the Mulan PSL v2.
// # - You may obtain a copy of Mulan PSL v2 at:
// # -     http://license.coscl.org.cn/MulanPSL2
// # - THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
// # - IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
// # - PURPOSE.
// # - See the Mulan PSL v2 for more details.
// ##- @Description: generate grpc
// ##- @Author: wujing
// ##- @Create: 2019-04-25
// #######################################################################
#ifndef GRPC_container_2eproto__INCLUDED
#define GRPC_container_2eproto__INCLUDED

#include "container.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace containers {

class ContainerService final {
 public:
  static constexpr char const* service_full_name() {
    return "containers.ContainerService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Create(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::containers::CreateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::CreateResponse>> AsyncCreate(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::CreateResponse>>(AsyncCreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::CreateResponse>> PrepareAsyncCreate(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::CreateResponse>>(PrepareAsyncCreateRaw(context, request, cq));
    }
    virtual ::grpc::Status Start(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::containers::StartResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StartResponse>> AsyncStart(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StartResponse>>(AsyncStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StartResponse>> PrepareAsyncStart(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StartResponse>>(PrepareAsyncStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>> RemoteStart(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>>(RemoteStartRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>> AsyncRemoteStart(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>>(AsyncRemoteStartRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>> PrepareAsyncRemoteStart(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>>(PrepareAsyncRemoteStartRaw(context, cq));
    }
    virtual ::grpc::Status Top(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::containers::TopResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::TopResponse>> AsyncTop(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::TopResponse>>(AsyncTopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::TopResponse>> PrepareAsyncTop(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::TopResponse>>(PrepareAsyncTopRaw(context, request, cq));
    }
    virtual ::grpc::Status Stop(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::containers::StopResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StopResponse>> AsyncStop(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StopResponse>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StopResponse>> PrepareAsyncStop(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StopResponse>>(PrepareAsyncStopRaw(context, request, cq));
    }
    virtual ::grpc::Status Kill(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::containers::KillResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::KillResponse>> AsyncKill(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::KillResponse>>(AsyncKillRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::KillResponse>> PrepareAsyncKill(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::KillResponse>>(PrepareAsyncKillRaw(context, request, cq));
    }
    virtual ::grpc::Status Delete(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::containers::DeleteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::DeleteResponse>> AsyncDelete(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::DeleteResponse>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::DeleteResponse>> PrepareAsyncDelete(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::DeleteResponse>>(PrepareAsyncDeleteRaw(context, request, cq));
    }
    virtual ::grpc::Status Pause(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::containers::PauseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::PauseResponse>> AsyncPause(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::PauseResponse>>(AsyncPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::PauseResponse>> PrepareAsyncPause(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::PauseResponse>>(PrepareAsyncPauseRaw(context, request, cq));
    }
    virtual ::grpc::Status Resume(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::containers::ResumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResumeResponse>> AsyncResume(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResumeResponse>>(AsyncResumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResumeResponse>> PrepareAsyncResume(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResumeResponse>>(PrepareAsyncResumeRaw(context, request, cq));
    }
    virtual ::grpc::Status Inspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::containers::InspectContainerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::InspectContainerResponse>> AsyncInspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::InspectContainerResponse>>(AsyncInspectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::InspectContainerResponse>> PrepareAsyncInspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::InspectContainerResponse>>(PrepareAsyncInspectRaw(context, request, cq));
    }
    virtual ::grpc::Status List(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::containers::ListResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ListResponse>> AsyncList(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ListResponse>>(AsyncListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ListResponse>> PrepareAsyncList(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ListResponse>>(PrepareAsyncListRaw(context, request, cq));
    }
    virtual ::grpc::Status Stats(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::containers::StatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StatsResponse>> AsyncStats(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StatsResponse>>(AsyncStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StatsResponse>> PrepareAsyncStats(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::StatsResponse>>(PrepareAsyncStatsRaw(context, request, cq));
    }
    virtual ::grpc::Status Wait(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::containers::WaitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::WaitResponse>> AsyncWait(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::WaitResponse>>(AsyncWaitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::WaitResponse>> PrepareAsyncWait(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::WaitResponse>>(PrepareAsyncWaitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::containers::Event>> Events(::grpc::ClientContext* context, const ::containers::EventsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::containers::Event>>(EventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::Event>> AsyncEvents(::grpc::ClientContext* context, const ::containers::EventsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::Event>>(AsyncEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::Event>> PrepareAsyncEvents(::grpc::ClientContext* context, const ::containers::EventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::Event>>(PrepareAsyncEventsRaw(context, request, cq));
    }
    virtual ::grpc::Status Exec(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::containers::ExecResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExecResponse>> AsyncExec(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExecResponse>>(AsyncExecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExecResponse>> PrepareAsyncExec(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExecResponse>>(PrepareAsyncExecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>> RemoteExec(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>>(RemoteExecRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>> AsyncRemoteExec(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>>(AsyncRemoteExecRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>> PrepareAsyncRemoteExec(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>>(PrepareAsyncRemoteExecRaw(context, cq));
    }
    virtual ::grpc::Status Version(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::containers::VersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::VersionResponse>> AsyncVersion(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::VersionResponse>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::VersionResponse>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::VersionResponse>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    virtual ::grpc::Status Info(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::containers::InfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::InfoResponse>> AsyncInfo(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::InfoResponse>>(AsyncInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::InfoResponse>> PrepareAsyncInfo(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::InfoResponse>>(PrepareAsyncInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status Update(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::containers::UpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::UpdateResponse>> AsyncUpdate(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::UpdateResponse>>(AsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::UpdateResponse>> PrepareAsyncUpdate(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::UpdateResponse>>(PrepareAsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>> Attach(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>>(AttachRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>> AsyncAttach(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>>(AsyncAttachRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>> PrepareAsyncAttach(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>>(PrepareAsyncAttachRaw(context, cq));
    }
    virtual ::grpc::Status Restart(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::containers::RestartResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::RestartResponse>> AsyncRestart(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::RestartResponse>>(AsyncRestartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::RestartResponse>> PrepareAsyncRestart(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::RestartResponse>>(PrepareAsyncRestartRaw(context, request, cq));
    }
    virtual ::grpc::Status Export(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::containers::ExportResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExportResponse>> AsyncExport(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExportResponse>>(AsyncExportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExportResponse>> PrepareAsyncExport(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExportResponse>>(PrepareAsyncExportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::containers::CopyFromContainerResponse>> CopyFromContainer(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::containers::CopyFromContainerResponse>>(CopyFromContainerRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::CopyFromContainerResponse>> AsyncCopyFromContainer(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::CopyFromContainerResponse>>(AsyncCopyFromContainerRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::CopyFromContainerResponse>> PrepareAsyncCopyFromContainer(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::CopyFromContainerResponse>>(PrepareAsyncCopyFromContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>> CopyToContainer(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>>(CopyToContainerRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>> AsyncCopyToContainer(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>>(AsyncCopyToContainerRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>> PrepareAsyncCopyToContainer(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>>(PrepareAsyncCopyToContainerRaw(context, cq));
    }
    virtual ::grpc::Status Rename(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::containers::RenameResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::RenameResponse>> AsyncRename(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::RenameResponse>>(AsyncRenameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::RenameResponse>> PrepareAsyncRename(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::RenameResponse>>(PrepareAsyncRenameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::containers::LogsResponse>> Logs(::grpc::ClientContext* context, const ::containers::LogsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::containers::LogsResponse>>(LogsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::LogsResponse>> AsyncLogs(::grpc::ClientContext* context, const ::containers::LogsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::LogsResponse>>(AsyncLogsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::LogsResponse>> PrepareAsyncLogs(::grpc::ClientContext* context, const ::containers::LogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::containers::LogsResponse>>(PrepareAsyncLogsRaw(context, request, cq));
    }
    virtual ::grpc::Status Resize(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::containers::ResizeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResizeResponse>> AsyncResize(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResizeResponse>>(AsyncResizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResizeResponse>> PrepareAsyncResize(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResizeResponse>>(PrepareAsyncResizeRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Create(::grpc::ClientContext* context, const ::containers::CreateRequest* request, ::containers::CreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::CreateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Create(::grpc::ClientContext* context, const ::containers::CreateRequest* request, ::containers::CreateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Create(::grpc::ClientContext* context, const ::containers::CreateRequest* request, ::containers::CreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::CreateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::CreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Start(::grpc::ClientContext* context, const ::containers::StartRequest* request, ::containers::StartResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StartResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Start(::grpc::ClientContext* context, const ::containers::StartRequest* request, ::containers::StartResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Start(::grpc::ClientContext* context, const ::containers::StartRequest* request, ::containers::StartResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StartResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StartResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoteStart(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::containers::RemoteStartRequest,::containers::RemoteStartResponse>* reactor) = 0;
      #else
      virtual void RemoteStart(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::containers::RemoteStartRequest,::containers::RemoteStartResponse>* reactor) = 0;
      #endif
      virtual void Top(::grpc::ClientContext* context, const ::containers::TopRequest* request, ::containers::TopResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Top(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::TopResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Top(::grpc::ClientContext* context, const ::containers::TopRequest* request, ::containers::TopResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Top(::grpc::ClientContext* context, const ::containers::TopRequest* request, ::containers::TopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Top(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::TopResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Top(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::TopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Stop(::grpc::ClientContext* context, const ::containers::StopRequest* request, ::containers::StopResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StopResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Stop(::grpc::ClientContext* context, const ::containers::StopRequest* request, ::containers::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Stop(::grpc::ClientContext* context, const ::containers::StopRequest* request, ::containers::StopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Kill(::grpc::ClientContext* context, const ::containers::KillRequest* request, ::containers::KillResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Kill(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::KillResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Kill(::grpc::ClientContext* context, const ::containers::KillRequest* request, ::containers::KillResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Kill(::grpc::ClientContext* context, const ::containers::KillRequest* request, ::containers::KillResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Kill(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::KillResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Kill(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::KillResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Delete(::grpc::ClientContext* context, const ::containers::DeleteRequest* request, ::containers::DeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::DeleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Delete(::grpc::ClientContext* context, const ::containers::DeleteRequest* request, ::containers::DeleteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Delete(::grpc::ClientContext* context, const ::containers::DeleteRequest* request, ::containers::DeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::DeleteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::DeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Pause(::grpc::ClientContext* context, const ::containers::PauseRequest* request, ::containers::PauseResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::PauseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Pause(::grpc::ClientContext* context, const ::containers::PauseRequest* request, ::containers::PauseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Pause(::grpc::ClientContext* context, const ::containers::PauseRequest* request, ::containers::PauseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::PauseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::PauseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Resume(::grpc::ClientContext* context, const ::containers::ResumeRequest* request, ::containers::ResumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Resume(::grpc::ClientContext* context, const ::containers::ResumeRequest* request, ::containers::ResumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Resume(::grpc::ClientContext* context, const ::containers::ResumeRequest* request, ::containers::ResumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Inspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest* request, ::containers::InspectContainerResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Inspect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InspectContainerResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Inspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest* request, ::containers::InspectContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Inspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest* request, ::containers::InspectContainerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Inspect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InspectContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Inspect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InspectContainerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void List(::grpc::ClientContext* context, const ::containers::ListRequest* request, ::containers::ListResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void List(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ListResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void List(::grpc::ClientContext* context, const ::containers::ListRequest* request, ::containers::ListResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void List(::grpc::ClientContext* context, const ::containers::ListRequest* request, ::containers::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void List(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ListResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void List(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Stats(::grpc::ClientContext* context, const ::containers::StatsRequest* request, ::containers::StatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Stats(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Stats(::grpc::ClientContext* context, const ::containers::StatsRequest* request, ::containers::StatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Stats(::grpc::ClientContext* context, const ::containers::StatsRequest* request, ::containers::StatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Stats(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Stats(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Wait(::grpc::ClientContext* context, const ::containers::WaitRequest* request, ::containers::WaitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Wait(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::WaitResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Wait(::grpc::ClientContext* context, const ::containers::WaitRequest* request, ::containers::WaitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Wait(::grpc::ClientContext* context, const ::containers::WaitRequest* request, ::containers::WaitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Wait(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::WaitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Wait(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::WaitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Events(::grpc::ClientContext* context, ::containers::EventsRequest* request, ::grpc::ClientReadReactor< ::containers::Event>* reactor) = 0;
      #else
      virtual void Events(::grpc::ClientContext* context, ::containers::EventsRequest* request, ::grpc::experimental::ClientReadReactor< ::containers::Event>* reactor) = 0;
      #endif
      virtual void Exec(::grpc::ClientContext* context, const ::containers::ExecRequest* request, ::containers::ExecResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Exec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExecResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Exec(::grpc::ClientContext* context, const ::containers::ExecRequest* request, ::containers::ExecResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Exec(::grpc::ClientContext* context, const ::containers::ExecRequest* request, ::containers::ExecResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Exec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExecResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Exec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExecResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RemoteExec(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::containers::RemoteExecRequest,::containers::RemoteExecResponse>* reactor) = 0;
      #else
      virtual void RemoteExec(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::containers::RemoteExecRequest,::containers::RemoteExecResponse>* reactor) = 0;
      #endif
      virtual void Version(::grpc::ClientContext* context, const ::containers::VersionRequest* request, ::containers::VersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Version(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::VersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Version(::grpc::ClientContext* context, const ::containers::VersionRequest* request, ::containers::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Version(::grpc::ClientContext* context, const ::containers::VersionRequest* request, ::containers::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Version(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Version(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Info(::grpc::ClientContext* context, const ::containers::InfoRequest* request, ::containers::InfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Info(::grpc::ClientContext* context, const ::containers::InfoRequest* request, ::containers::InfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Info(::grpc::ClientContext* context, const ::containers::InfoRequest* request, ::containers::InfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Update(::grpc::ClientContext* context, const ::containers::UpdateRequest* request, ::containers::UpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::UpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Update(::grpc::ClientContext* context, const ::containers::UpdateRequest* request, ::containers::UpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Update(::grpc::ClientContext* context, const ::containers::UpdateRequest* request, ::containers::UpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::UpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::UpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Attach(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::containers::AttachRequest,::containers::AttachResponse>* reactor) = 0;
      #else
      virtual void Attach(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::containers::AttachRequest,::containers::AttachResponse>* reactor) = 0;
      #endif
      virtual void Restart(::grpc::ClientContext* context, const ::containers::RestartRequest* request, ::containers::RestartResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Restart(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RestartResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Restart(::grpc::ClientContext* context, const ::containers::RestartRequest* request, ::containers::RestartResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Restart(::grpc::ClientContext* context, const ::containers::RestartRequest* request, ::containers::RestartResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Restart(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RestartResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Restart(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RestartResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Export(::grpc::ClientContext* context, const ::containers::ExportRequest* request, ::containers::ExportResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Export(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExportResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Export(::grpc::ClientContext* context, const ::containers::ExportRequest* request, ::containers::ExportResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Export(::grpc::ClientContext* context, const ::containers::ExportRequest* request, ::containers::ExportResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Export(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExportResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Export(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExportResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CopyFromContainer(::grpc::ClientContext* context, ::containers::CopyFromContainerRequest* request, ::grpc::ClientReadReactor< ::containers::CopyFromContainerResponse>* reactor) = 0;
      #else
      virtual void CopyFromContainer(::grpc::ClientContext* context, ::containers::CopyFromContainerRequest* request, ::grpc::experimental::ClientReadReactor< ::containers::CopyFromContainerResponse>* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CopyToContainer(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::containers::CopyToContainerRequest,::containers::CopyToContainerResponse>* reactor) = 0;
      #else
      virtual void CopyToContainer(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::containers::CopyToContainerRequest,::containers::CopyToContainerResponse>* reactor) = 0;
      #endif
      virtual void Rename(::grpc::ClientContext* context, const ::containers::RenameRequest* request, ::containers::RenameResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RenameResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Rename(::grpc::ClientContext* context, const ::containers::RenameRequest* request, ::containers::RenameResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Rename(::grpc::ClientContext* context, const ::containers::RenameRequest* request, ::containers::RenameResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RenameResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RenameResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Logs(::grpc::ClientContext* context, ::containers::LogsRequest* request, ::grpc::ClientReadReactor< ::containers::LogsResponse>* reactor) = 0;
      #else
      virtual void Logs(::grpc::ClientContext* context, ::containers::LogsRequest* request, ::grpc::experimental::ClientReadReactor< ::containers::LogsResponse>* reactor) = 0;
      #endif
      virtual void Resize(::grpc::ClientContext* context, const ::containers::ResizeRequest* request, ::containers::ResizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResizeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Resize(::grpc::ClientContext* context, const ::containers::ResizeRequest* request, ::containers::ResizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Resize(::grpc::ClientContext* context, const ::containers::ResizeRequest* request, ::containers::ResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResizeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::CreateResponse>* AsyncCreateRaw(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::CreateResponse>* PrepareAsyncCreateRaw(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::StartResponse>* AsyncStartRaw(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::StartResponse>* PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>* RemoteStartRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>* AsyncRemoteStartRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>* PrepareAsyncRemoteStartRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::TopResponse>* AsyncTopRaw(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::TopResponse>* PrepareAsyncTopRaw(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::StopResponse>* AsyncStopRaw(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::StopResponse>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::KillResponse>* AsyncKillRaw(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::KillResponse>* PrepareAsyncKillRaw(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::DeleteResponse>* AsyncDeleteRaw(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::DeleteResponse>* PrepareAsyncDeleteRaw(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::PauseResponse>* AsyncPauseRaw(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::PauseResponse>* PrepareAsyncPauseRaw(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResumeResponse>* AsyncResumeRaw(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResumeResponse>* PrepareAsyncResumeRaw(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::InspectContainerResponse>* AsyncInspectRaw(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::InspectContainerResponse>* PrepareAsyncInspectRaw(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ListResponse>* AsyncListRaw(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ListResponse>* PrepareAsyncListRaw(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::StatsResponse>* AsyncStatsRaw(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::StatsResponse>* PrepareAsyncStatsRaw(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::WaitResponse>* AsyncWaitRaw(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::WaitResponse>* PrepareAsyncWaitRaw(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::containers::Event>* EventsRaw(::grpc::ClientContext* context, const ::containers::EventsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::containers::Event>* AsyncEventsRaw(::grpc::ClientContext* context, const ::containers::EventsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::containers::Event>* PrepareAsyncEventsRaw(::grpc::ClientContext* context, const ::containers::EventsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExecResponse>* AsyncExecRaw(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExecResponse>* PrepareAsyncExecRaw(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>* RemoteExecRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>* AsyncRemoteExecRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>* PrepareAsyncRemoteExecRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::VersionResponse>* AsyncVersionRaw(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::VersionResponse>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::InfoResponse>* AsyncInfoRaw(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::InfoResponse>* PrepareAsyncInfoRaw(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::UpdateResponse>* AsyncUpdateRaw(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::UpdateResponse>* PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>* AttachRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>* AsyncAttachRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::containers::AttachRequest, ::containers::AttachResponse>* PrepareAsyncAttachRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::RestartResponse>* AsyncRestartRaw(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::RestartResponse>* PrepareAsyncRestartRaw(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExportResponse>* AsyncExportRaw(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ExportResponse>* PrepareAsyncExportRaw(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::containers::CopyFromContainerResponse>* CopyFromContainerRaw(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::containers::CopyFromContainerResponse>* AsyncCopyFromContainerRaw(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::containers::CopyFromContainerResponse>* PrepareAsyncCopyFromContainerRaw(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>* CopyToContainerRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>* AsyncCopyToContainerRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>* PrepareAsyncCopyToContainerRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::RenameResponse>* AsyncRenameRaw(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::RenameResponse>* PrepareAsyncRenameRaw(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::containers::LogsResponse>* LogsRaw(::grpc::ClientContext* context, const ::containers::LogsRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::containers::LogsResponse>* AsyncLogsRaw(::grpc::ClientContext* context, const ::containers::LogsRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::containers::LogsResponse>* PrepareAsyncLogsRaw(::grpc::ClientContext* context, const ::containers::LogsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResizeResponse>* AsyncResizeRaw(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::containers::ResizeResponse>* PrepareAsyncResizeRaw(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Create(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::containers::CreateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::CreateResponse>> AsyncCreate(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::CreateResponse>>(AsyncCreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::CreateResponse>> PrepareAsyncCreate(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::CreateResponse>>(PrepareAsyncCreateRaw(context, request, cq));
    }
    ::grpc::Status Start(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::containers::StartResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StartResponse>> AsyncStart(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StartResponse>>(AsyncStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StartResponse>> PrepareAsyncStart(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StartResponse>>(PrepareAsyncStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>> RemoteStart(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>>(RemoteStartRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>> AsyncRemoteStart(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>>(AsyncRemoteStartRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>> PrepareAsyncRemoteStart(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>>(PrepareAsyncRemoteStartRaw(context, cq));
    }
    ::grpc::Status Top(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::containers::TopResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::TopResponse>> AsyncTop(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::TopResponse>>(AsyncTopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::TopResponse>> PrepareAsyncTop(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::TopResponse>>(PrepareAsyncTopRaw(context, request, cq));
    }
    ::grpc::Status Stop(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::containers::StopResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StopResponse>> AsyncStop(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StopResponse>>(AsyncStopRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StopResponse>> PrepareAsyncStop(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StopResponse>>(PrepareAsyncStopRaw(context, request, cq));
    }
    ::grpc::Status Kill(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::containers::KillResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::KillResponse>> AsyncKill(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::KillResponse>>(AsyncKillRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::KillResponse>> PrepareAsyncKill(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::KillResponse>>(PrepareAsyncKillRaw(context, request, cq));
    }
    ::grpc::Status Delete(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::containers::DeleteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::DeleteResponse>> AsyncDelete(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::DeleteResponse>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::DeleteResponse>> PrepareAsyncDelete(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::DeleteResponse>>(PrepareAsyncDeleteRaw(context, request, cq));
    }
    ::grpc::Status Pause(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::containers::PauseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::PauseResponse>> AsyncPause(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::PauseResponse>>(AsyncPauseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::PauseResponse>> PrepareAsyncPause(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::PauseResponse>>(PrepareAsyncPauseRaw(context, request, cq));
    }
    ::grpc::Status Resume(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::containers::ResumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ResumeResponse>> AsyncResume(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ResumeResponse>>(AsyncResumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ResumeResponse>> PrepareAsyncResume(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ResumeResponse>>(PrepareAsyncResumeRaw(context, request, cq));
    }
    ::grpc::Status Inspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::containers::InspectContainerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::InspectContainerResponse>> AsyncInspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::InspectContainerResponse>>(AsyncInspectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::InspectContainerResponse>> PrepareAsyncInspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::InspectContainerResponse>>(PrepareAsyncInspectRaw(context, request, cq));
    }
    ::grpc::Status List(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::containers::ListResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ListResponse>> AsyncList(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ListResponse>>(AsyncListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ListResponse>> PrepareAsyncList(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ListResponse>>(PrepareAsyncListRaw(context, request, cq));
    }
    ::grpc::Status Stats(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::containers::StatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StatsResponse>> AsyncStats(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StatsResponse>>(AsyncStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StatsResponse>> PrepareAsyncStats(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::StatsResponse>>(PrepareAsyncStatsRaw(context, request, cq));
    }
    ::grpc::Status Wait(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::containers::WaitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::WaitResponse>> AsyncWait(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::WaitResponse>>(AsyncWaitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::WaitResponse>> PrepareAsyncWait(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::WaitResponse>>(PrepareAsyncWaitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::containers::Event>> Events(::grpc::ClientContext* context, const ::containers::EventsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::containers::Event>>(EventsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::Event>> AsyncEvents(::grpc::ClientContext* context, const ::containers::EventsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::Event>>(AsyncEventsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::Event>> PrepareAsyncEvents(::grpc::ClientContext* context, const ::containers::EventsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::Event>>(PrepareAsyncEventsRaw(context, request, cq));
    }
    ::grpc::Status Exec(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::containers::ExecResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ExecResponse>> AsyncExec(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ExecResponse>>(AsyncExecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ExecResponse>> PrepareAsyncExec(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ExecResponse>>(PrepareAsyncExecRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>> RemoteExec(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>>(RemoteExecRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>> AsyncRemoteExec(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>>(AsyncRemoteExecRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>> PrepareAsyncRemoteExec(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>>(PrepareAsyncRemoteExecRaw(context, cq));
    }
    ::grpc::Status Version(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::containers::VersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::VersionResponse>> AsyncVersion(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::VersionResponse>>(AsyncVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::VersionResponse>> PrepareAsyncVersion(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::VersionResponse>>(PrepareAsyncVersionRaw(context, request, cq));
    }
    ::grpc::Status Info(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::containers::InfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::InfoResponse>> AsyncInfo(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::InfoResponse>>(AsyncInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::InfoResponse>> PrepareAsyncInfo(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::InfoResponse>>(PrepareAsyncInfoRaw(context, request, cq));
    }
    ::grpc::Status Update(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::containers::UpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::UpdateResponse>> AsyncUpdate(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::UpdateResponse>>(AsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::UpdateResponse>> PrepareAsyncUpdate(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::UpdateResponse>>(PrepareAsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>> Attach(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>>(AttachRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>> AsyncAttach(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>>(AsyncAttachRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>> PrepareAsyncAttach(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>>(PrepareAsyncAttachRaw(context, cq));
    }
    ::grpc::Status Restart(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::containers::RestartResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::RestartResponse>> AsyncRestart(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::RestartResponse>>(AsyncRestartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::RestartResponse>> PrepareAsyncRestart(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::RestartResponse>>(PrepareAsyncRestartRaw(context, request, cq));
    }
    ::grpc::Status Export(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::containers::ExportResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ExportResponse>> AsyncExport(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ExportResponse>>(AsyncExportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ExportResponse>> PrepareAsyncExport(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ExportResponse>>(PrepareAsyncExportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::containers::CopyFromContainerResponse>> CopyFromContainer(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::containers::CopyFromContainerResponse>>(CopyFromContainerRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::CopyFromContainerResponse>> AsyncCopyFromContainer(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::CopyFromContainerResponse>>(AsyncCopyFromContainerRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::CopyFromContainerResponse>> PrepareAsyncCopyFromContainer(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::CopyFromContainerResponse>>(PrepareAsyncCopyFromContainerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>> CopyToContainer(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>>(CopyToContainerRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>> AsyncCopyToContainer(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>>(AsyncCopyToContainerRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>> PrepareAsyncCopyToContainer(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>>(PrepareAsyncCopyToContainerRaw(context, cq));
    }
    ::grpc::Status Rename(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::containers::RenameResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::RenameResponse>> AsyncRename(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::RenameResponse>>(AsyncRenameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::RenameResponse>> PrepareAsyncRename(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::RenameResponse>>(PrepareAsyncRenameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::containers::LogsResponse>> Logs(::grpc::ClientContext* context, const ::containers::LogsRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::containers::LogsResponse>>(LogsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::LogsResponse>> AsyncLogs(::grpc::ClientContext* context, const ::containers::LogsRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::LogsResponse>>(AsyncLogsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::LogsResponse>> PrepareAsyncLogs(::grpc::ClientContext* context, const ::containers::LogsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::containers::LogsResponse>>(PrepareAsyncLogsRaw(context, request, cq));
    }
    ::grpc::Status Resize(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::containers::ResizeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ResizeResponse>> AsyncResize(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ResizeResponse>>(AsyncResizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ResizeResponse>> PrepareAsyncResize(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::containers::ResizeResponse>>(PrepareAsyncResizeRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Create(::grpc::ClientContext* context, const ::containers::CreateRequest* request, ::containers::CreateResponse* response, std::function<void(::grpc::Status)>) override;
      void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::CreateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Create(::grpc::ClientContext* context, const ::containers::CreateRequest* request, ::containers::CreateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Create(::grpc::ClientContext* context, const ::containers::CreateRequest* request, ::containers::CreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::CreateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::CreateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Start(::grpc::ClientContext* context, const ::containers::StartRequest* request, ::containers::StartResponse* response, std::function<void(::grpc::Status)>) override;
      void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StartResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Start(::grpc::ClientContext* context, const ::containers::StartRequest* request, ::containers::StartResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Start(::grpc::ClientContext* context, const ::containers::StartRequest* request, ::containers::StartResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StartResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StartResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoteStart(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::containers::RemoteStartRequest,::containers::RemoteStartResponse>* reactor) override;
      #else
      void RemoteStart(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::containers::RemoteStartRequest,::containers::RemoteStartResponse>* reactor) override;
      #endif
      void Top(::grpc::ClientContext* context, const ::containers::TopRequest* request, ::containers::TopResponse* response, std::function<void(::grpc::Status)>) override;
      void Top(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::TopResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Top(::grpc::ClientContext* context, const ::containers::TopRequest* request, ::containers::TopResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Top(::grpc::ClientContext* context, const ::containers::TopRequest* request, ::containers::TopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Top(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::TopResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Top(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::TopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Stop(::grpc::ClientContext* context, const ::containers::StopRequest* request, ::containers::StopResponse* response, std::function<void(::grpc::Status)>) override;
      void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StopResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Stop(::grpc::ClientContext* context, const ::containers::StopRequest* request, ::containers::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Stop(::grpc::ClientContext* context, const ::containers::StopRequest* request, ::containers::StopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StopResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StopResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Kill(::grpc::ClientContext* context, const ::containers::KillRequest* request, ::containers::KillResponse* response, std::function<void(::grpc::Status)>) override;
      void Kill(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::KillResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Kill(::grpc::ClientContext* context, const ::containers::KillRequest* request, ::containers::KillResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Kill(::grpc::ClientContext* context, const ::containers::KillRequest* request, ::containers::KillResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Kill(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::KillResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Kill(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::KillResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Delete(::grpc::ClientContext* context, const ::containers::DeleteRequest* request, ::containers::DeleteResponse* response, std::function<void(::grpc::Status)>) override;
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::DeleteResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Delete(::grpc::ClientContext* context, const ::containers::DeleteRequest* request, ::containers::DeleteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Delete(::grpc::ClientContext* context, const ::containers::DeleteRequest* request, ::containers::DeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::DeleteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::DeleteResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Pause(::grpc::ClientContext* context, const ::containers::PauseRequest* request, ::containers::PauseResponse* response, std::function<void(::grpc::Status)>) override;
      void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::PauseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Pause(::grpc::ClientContext* context, const ::containers::PauseRequest* request, ::containers::PauseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Pause(::grpc::ClientContext* context, const ::containers::PauseRequest* request, ::containers::PauseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::PauseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Pause(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::PauseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Resume(::grpc::ClientContext* context, const ::containers::ResumeRequest* request, ::containers::ResumeResponse* response, std::function<void(::grpc::Status)>) override;
      void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Resume(::grpc::ClientContext* context, const ::containers::ResumeRequest* request, ::containers::ResumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Resume(::grpc::ClientContext* context, const ::containers::ResumeRequest* request, ::containers::ResumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Resume(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Inspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest* request, ::containers::InspectContainerResponse* response, std::function<void(::grpc::Status)>) override;
      void Inspect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InspectContainerResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Inspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest* request, ::containers::InspectContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Inspect(::grpc::ClientContext* context, const ::containers::InspectContainerRequest* request, ::containers::InspectContainerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Inspect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InspectContainerResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Inspect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InspectContainerResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void List(::grpc::ClientContext* context, const ::containers::ListRequest* request, ::containers::ListResponse* response, std::function<void(::grpc::Status)>) override;
      void List(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ListResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void List(::grpc::ClientContext* context, const ::containers::ListRequest* request, ::containers::ListResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void List(::grpc::ClientContext* context, const ::containers::ListRequest* request, ::containers::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void List(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ListResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void List(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ListResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Stats(::grpc::ClientContext* context, const ::containers::StatsRequest* request, ::containers::StatsResponse* response, std::function<void(::grpc::Status)>) override;
      void Stats(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StatsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Stats(::grpc::ClientContext* context, const ::containers::StatsRequest* request, ::containers::StatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Stats(::grpc::ClientContext* context, const ::containers::StatsRequest* request, ::containers::StatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Stats(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Stats(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::StatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Wait(::grpc::ClientContext* context, const ::containers::WaitRequest* request, ::containers::WaitResponse* response, std::function<void(::grpc::Status)>) override;
      void Wait(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::WaitResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Wait(::grpc::ClientContext* context, const ::containers::WaitRequest* request, ::containers::WaitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Wait(::grpc::ClientContext* context, const ::containers::WaitRequest* request, ::containers::WaitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Wait(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::WaitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Wait(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::WaitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Events(::grpc::ClientContext* context, ::containers::EventsRequest* request, ::grpc::ClientReadReactor< ::containers::Event>* reactor) override;
      #else
      void Events(::grpc::ClientContext* context, ::containers::EventsRequest* request, ::grpc::experimental::ClientReadReactor< ::containers::Event>* reactor) override;
      #endif
      void Exec(::grpc::ClientContext* context, const ::containers::ExecRequest* request, ::containers::ExecResponse* response, std::function<void(::grpc::Status)>) override;
      void Exec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExecResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Exec(::grpc::ClientContext* context, const ::containers::ExecRequest* request, ::containers::ExecResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Exec(::grpc::ClientContext* context, const ::containers::ExecRequest* request, ::containers::ExecResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Exec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExecResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Exec(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExecResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RemoteExec(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::containers::RemoteExecRequest,::containers::RemoteExecResponse>* reactor) override;
      #else
      void RemoteExec(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::containers::RemoteExecRequest,::containers::RemoteExecResponse>* reactor) override;
      #endif
      void Version(::grpc::ClientContext* context, const ::containers::VersionRequest* request, ::containers::VersionResponse* response, std::function<void(::grpc::Status)>) override;
      void Version(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::VersionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Version(::grpc::ClientContext* context, const ::containers::VersionRequest* request, ::containers::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Version(::grpc::ClientContext* context, const ::containers::VersionRequest* request, ::containers::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Version(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::VersionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Version(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::VersionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Info(::grpc::ClientContext* context, const ::containers::InfoRequest* request, ::containers::InfoResponse* response, std::function<void(::grpc::Status)>) override;
      void Info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InfoResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Info(::grpc::ClientContext* context, const ::containers::InfoRequest* request, ::containers::InfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Info(::grpc::ClientContext* context, const ::containers::InfoRequest* request, ::containers::InfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Info(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::InfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Update(::grpc::ClientContext* context, const ::containers::UpdateRequest* request, ::containers::UpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::UpdateResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Update(::grpc::ClientContext* context, const ::containers::UpdateRequest* request, ::containers::UpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Update(::grpc::ClientContext* context, const ::containers::UpdateRequest* request, ::containers::UpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::UpdateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::UpdateResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Attach(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::containers::AttachRequest,::containers::AttachResponse>* reactor) override;
      #else
      void Attach(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::containers::AttachRequest,::containers::AttachResponse>* reactor) override;
      #endif
      void Restart(::grpc::ClientContext* context, const ::containers::RestartRequest* request, ::containers::RestartResponse* response, std::function<void(::grpc::Status)>) override;
      void Restart(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RestartResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Restart(::grpc::ClientContext* context, const ::containers::RestartRequest* request, ::containers::RestartResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Restart(::grpc::ClientContext* context, const ::containers::RestartRequest* request, ::containers::RestartResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Restart(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RestartResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Restart(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RestartResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Export(::grpc::ClientContext* context, const ::containers::ExportRequest* request, ::containers::ExportResponse* response, std::function<void(::grpc::Status)>) override;
      void Export(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExportResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Export(::grpc::ClientContext* context, const ::containers::ExportRequest* request, ::containers::ExportResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Export(::grpc::ClientContext* context, const ::containers::ExportRequest* request, ::containers::ExportResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Export(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExportResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Export(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ExportResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CopyFromContainer(::grpc::ClientContext* context, ::containers::CopyFromContainerRequest* request, ::grpc::ClientReadReactor< ::containers::CopyFromContainerResponse>* reactor) override;
      #else
      void CopyFromContainer(::grpc::ClientContext* context, ::containers::CopyFromContainerRequest* request, ::grpc::experimental::ClientReadReactor< ::containers::CopyFromContainerResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CopyToContainer(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::containers::CopyToContainerRequest,::containers::CopyToContainerResponse>* reactor) override;
      #else
      void CopyToContainer(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::containers::CopyToContainerRequest,::containers::CopyToContainerResponse>* reactor) override;
      #endif
      void Rename(::grpc::ClientContext* context, const ::containers::RenameRequest* request, ::containers::RenameResponse* response, std::function<void(::grpc::Status)>) override;
      void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RenameResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Rename(::grpc::ClientContext* context, const ::containers::RenameRequest* request, ::containers::RenameResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Rename(::grpc::ClientContext* context, const ::containers::RenameRequest* request, ::containers::RenameResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RenameResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Rename(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::RenameResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Logs(::grpc::ClientContext* context, ::containers::LogsRequest* request, ::grpc::ClientReadReactor< ::containers::LogsResponse>* reactor) override;
      #else
      void Logs(::grpc::ClientContext* context, ::containers::LogsRequest* request, ::grpc::experimental::ClientReadReactor< ::containers::LogsResponse>* reactor) override;
      #endif
      void Resize(::grpc::ClientContext* context, const ::containers::ResizeRequest* request, ::containers::ResizeResponse* response, std::function<void(::grpc::Status)>) override;
      void Resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResizeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Resize(::grpc::ClientContext* context, const ::containers::ResizeRequest* request, ::containers::ResizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Resize(::grpc::ClientContext* context, const ::containers::ResizeRequest* request, ::containers::ResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResizeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Resize(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::containers::ResizeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::containers::CreateResponse>* AsyncCreateRaw(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::CreateResponse>* PrepareAsyncCreateRaw(::grpc::ClientContext* context, const ::containers::CreateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::StartResponse>* AsyncStartRaw(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::StartResponse>* PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::containers::StartRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>* RemoteStartRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>* AsyncRemoteStartRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>* PrepareAsyncRemoteStartRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::TopResponse>* AsyncTopRaw(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::TopResponse>* PrepareAsyncTopRaw(::grpc::ClientContext* context, const ::containers::TopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::StopResponse>* AsyncStopRaw(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::StopResponse>* PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::containers::StopRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::KillResponse>* AsyncKillRaw(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::KillResponse>* PrepareAsyncKillRaw(::grpc::ClientContext* context, const ::containers::KillRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::DeleteResponse>* AsyncDeleteRaw(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::DeleteResponse>* PrepareAsyncDeleteRaw(::grpc::ClientContext* context, const ::containers::DeleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::PauseResponse>* AsyncPauseRaw(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::PauseResponse>* PrepareAsyncPauseRaw(::grpc::ClientContext* context, const ::containers::PauseRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ResumeResponse>* AsyncResumeRaw(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ResumeResponse>* PrepareAsyncResumeRaw(::grpc::ClientContext* context, const ::containers::ResumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::InspectContainerResponse>* AsyncInspectRaw(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::InspectContainerResponse>* PrepareAsyncInspectRaw(::grpc::ClientContext* context, const ::containers::InspectContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ListResponse>* AsyncListRaw(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ListResponse>* PrepareAsyncListRaw(::grpc::ClientContext* context, const ::containers::ListRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::StatsResponse>* AsyncStatsRaw(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::StatsResponse>* PrepareAsyncStatsRaw(::grpc::ClientContext* context, const ::containers::StatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::WaitResponse>* AsyncWaitRaw(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::WaitResponse>* PrepareAsyncWaitRaw(::grpc::ClientContext* context, const ::containers::WaitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::containers::Event>* EventsRaw(::grpc::ClientContext* context, const ::containers::EventsRequest& request) override;
    ::grpc::ClientAsyncReader< ::containers::Event>* AsyncEventsRaw(::grpc::ClientContext* context, const ::containers::EventsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::containers::Event>* PrepareAsyncEventsRaw(::grpc::ClientContext* context, const ::containers::EventsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ExecResponse>* AsyncExecRaw(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ExecResponse>* PrepareAsyncExecRaw(::grpc::ClientContext* context, const ::containers::ExecRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>* RemoteExecRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>* AsyncRemoteExecRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>* PrepareAsyncRemoteExecRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::VersionResponse>* AsyncVersionRaw(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::VersionResponse>* PrepareAsyncVersionRaw(::grpc::ClientContext* context, const ::containers::VersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::InfoResponse>* AsyncInfoRaw(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::InfoResponse>* PrepareAsyncInfoRaw(::grpc::ClientContext* context, const ::containers::InfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::UpdateResponse>* AsyncUpdateRaw(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::UpdateResponse>* PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::containers::UpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>* AttachRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>* AsyncAttachRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::containers::AttachRequest, ::containers::AttachResponse>* PrepareAsyncAttachRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::RestartResponse>* AsyncRestartRaw(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::RestartResponse>* PrepareAsyncRestartRaw(::grpc::ClientContext* context, const ::containers::RestartRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ExportResponse>* AsyncExportRaw(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ExportResponse>* PrepareAsyncExportRaw(::grpc::ClientContext* context, const ::containers::ExportRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::containers::CopyFromContainerResponse>* CopyFromContainerRaw(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request) override;
    ::grpc::ClientAsyncReader< ::containers::CopyFromContainerResponse>* AsyncCopyFromContainerRaw(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::containers::CopyFromContainerResponse>* PrepareAsyncCopyFromContainerRaw(::grpc::ClientContext* context, const ::containers::CopyFromContainerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>* CopyToContainerRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>* AsyncCopyToContainerRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>* PrepareAsyncCopyToContainerRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::RenameResponse>* AsyncRenameRaw(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::RenameResponse>* PrepareAsyncRenameRaw(::grpc::ClientContext* context, const ::containers::RenameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::containers::LogsResponse>* LogsRaw(::grpc::ClientContext* context, const ::containers::LogsRequest& request) override;
    ::grpc::ClientAsyncReader< ::containers::LogsResponse>* AsyncLogsRaw(::grpc::ClientContext* context, const ::containers::LogsRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::containers::LogsResponse>* PrepareAsyncLogsRaw(::grpc::ClientContext* context, const ::containers::LogsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ResizeResponse>* AsyncResizeRaw(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::containers::ResizeResponse>* PrepareAsyncResizeRaw(::grpc::ClientContext* context, const ::containers::ResizeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Create_;
    const ::grpc::internal::RpcMethod rpcmethod_Start_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoteStart_;
    const ::grpc::internal::RpcMethod rpcmethod_Top_;
    const ::grpc::internal::RpcMethod rpcmethod_Stop_;
    const ::grpc::internal::RpcMethod rpcmethod_Kill_;
    const ::grpc::internal::RpcMethod rpcmethod_Delete_;
    const ::grpc::internal::RpcMethod rpcmethod_Pause_;
    const ::grpc::internal::RpcMethod rpcmethod_Resume_;
    const ::grpc::internal::RpcMethod rpcmethod_Inspect_;
    const ::grpc::internal::RpcMethod rpcmethod_List_;
    const ::grpc::internal::RpcMethod rpcmethod_Stats_;
    const ::grpc::internal::RpcMethod rpcmethod_Wait_;
    const ::grpc::internal::RpcMethod rpcmethod_Events_;
    const ::grpc::internal::RpcMethod rpcmethod_Exec_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoteExec_;
    const ::grpc::internal::RpcMethod rpcmethod_Version_;
    const ::grpc::internal::RpcMethod rpcmethod_Info_;
    const ::grpc::internal::RpcMethod rpcmethod_Update_;
    const ::grpc::internal::RpcMethod rpcmethod_Attach_;
    const ::grpc::internal::RpcMethod rpcmethod_Restart_;
    const ::grpc::internal::RpcMethod rpcmethod_Export_;
    const ::grpc::internal::RpcMethod rpcmethod_CopyFromContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_CopyToContainer_;
    const ::grpc::internal::RpcMethod rpcmethod_Rename_;
    const ::grpc::internal::RpcMethod rpcmethod_Logs_;
    const ::grpc::internal::RpcMethod rpcmethod_Resize_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Create(::grpc::ServerContext* context, const ::containers::CreateRequest* request, ::containers::CreateResponse* response);
    virtual ::grpc::Status Start(::grpc::ServerContext* context, const ::containers::StartRequest* request, ::containers::StartResponse* response);
    virtual ::grpc::Status RemoteStart(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::containers::RemoteStartResponse, ::containers::RemoteStartRequest>* stream);
    virtual ::grpc::Status Top(::grpc::ServerContext* context, const ::containers::TopRequest* request, ::containers::TopResponse* response);
    virtual ::grpc::Status Stop(::grpc::ServerContext* context, const ::containers::StopRequest* request, ::containers::StopResponse* response);
    virtual ::grpc::Status Kill(::grpc::ServerContext* context, const ::containers::KillRequest* request, ::containers::KillResponse* response);
    virtual ::grpc::Status Delete(::grpc::ServerContext* context, const ::containers::DeleteRequest* request, ::containers::DeleteResponse* response);
    virtual ::grpc::Status Pause(::grpc::ServerContext* context, const ::containers::PauseRequest* request, ::containers::PauseResponse* response);
    virtual ::grpc::Status Resume(::grpc::ServerContext* context, const ::containers::ResumeRequest* request, ::containers::ResumeResponse* response);
    virtual ::grpc::Status Inspect(::grpc::ServerContext* context, const ::containers::InspectContainerRequest* request, ::containers::InspectContainerResponse* response);
    virtual ::grpc::Status List(::grpc::ServerContext* context, const ::containers::ListRequest* request, ::containers::ListResponse* response);
    virtual ::grpc::Status Stats(::grpc::ServerContext* context, const ::containers::StatsRequest* request, ::containers::StatsResponse* response);
    virtual ::grpc::Status Wait(::grpc::ServerContext* context, const ::containers::WaitRequest* request, ::containers::WaitResponse* response);
    virtual ::grpc::Status Events(::grpc::ServerContext* context, const ::containers::EventsRequest* request, ::grpc::ServerWriter< ::containers::Event>* writer);
    virtual ::grpc::Status Exec(::grpc::ServerContext* context, const ::containers::ExecRequest* request, ::containers::ExecResponse* response);
    virtual ::grpc::Status RemoteExec(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::containers::RemoteExecResponse, ::containers::RemoteExecRequest>* stream);
    virtual ::grpc::Status Version(::grpc::ServerContext* context, const ::containers::VersionRequest* request, ::containers::VersionResponse* response);
    virtual ::grpc::Status Info(::grpc::ServerContext* context, const ::containers::InfoRequest* request, ::containers::InfoResponse* response);
    virtual ::grpc::Status Update(::grpc::ServerContext* context, const ::containers::UpdateRequest* request, ::containers::UpdateResponse* response);
    virtual ::grpc::Status Attach(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::containers::AttachResponse, ::containers::AttachRequest>* stream);
    virtual ::grpc::Status Restart(::grpc::ServerContext* context, const ::containers::RestartRequest* request, ::containers::RestartResponse* response);
    virtual ::grpc::Status Export(::grpc::ServerContext* context, const ::containers::ExportRequest* request, ::containers::ExportResponse* response);
    virtual ::grpc::Status CopyFromContainer(::grpc::ServerContext* context, const ::containers::CopyFromContainerRequest* request, ::grpc::ServerWriter< ::containers::CopyFromContainerResponse>* writer);
    virtual ::grpc::Status CopyToContainer(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::containers::CopyToContainerResponse, ::containers::CopyToContainerRequest>* stream);
    virtual ::grpc::Status Rename(::grpc::ServerContext* context, const ::containers::RenameRequest* request, ::containers::RenameResponse* response);
    virtual ::grpc::Status Logs(::grpc::ServerContext* context, const ::containers::LogsRequest* request, ::grpc::ServerWriter< ::containers::LogsResponse>* writer);
    virtual ::grpc::Status Resize(::grpc::ServerContext* context, const ::containers::ResizeRequest* request, ::containers::ResizeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Create() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::containers::CreateRequest* /*request*/, ::containers::CreateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreate(::grpc::ServerContext* context, ::containers::CreateRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::CreateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Start() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::containers::StartRequest* /*request*/, ::containers::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStart(::grpc::ServerContext* context, ::containers::StartRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::StartResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoteStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoteStart() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_RemoteStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteStart(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteStartResponse, ::containers::RemoteStartRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoteStart(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::containers::RemoteStartResponse, ::containers::RemoteStartRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Top : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Top() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Top() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Top(::grpc::ServerContext* /*context*/, const ::containers::TopRequest* /*request*/, ::containers::TopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTop(::grpc::ServerContext* context, ::containers::TopRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::TopResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Stop() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::containers::StopRequest* /*request*/, ::containers::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::containers::StopRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::StopResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Kill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Kill() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Kill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Kill(::grpc::ServerContext* /*context*/, const ::containers::KillRequest* /*request*/, ::containers::KillResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKill(::grpc::ServerContext* context, ::containers::KillRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::KillResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Delete() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::containers::DeleteRequest* /*request*/, ::containers::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelete(::grpc::ServerContext* context, ::containers::DeleteRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::DeleteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Pause() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::containers::PauseRequest* /*request*/, ::containers::PauseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPause(::grpc::ServerContext* context, ::containers::PauseRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::PauseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Resume() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::containers::ResumeRequest* /*request*/, ::containers::ResumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResume(::grpc::ServerContext* context, ::containers::ResumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::ResumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Inspect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Inspect() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_Inspect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Inspect(::grpc::ServerContext* /*context*/, const ::containers::InspectContainerRequest* /*request*/, ::containers::InspectContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInspect(::grpc::ServerContext* context, ::containers::InspectContainerRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::InspectContainerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_List() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::containers::ListRequest* /*request*/, ::containers::ListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestList(::grpc::ServerContext* context, ::containers::ListRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::ListResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Stats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Stats() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_Stats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stats(::grpc::ServerContext* /*context*/, const ::containers::StatsRequest* /*request*/, ::containers::StatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStats(::grpc::ServerContext* context, ::containers::StatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::StatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Wait() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_Wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Wait(::grpc::ServerContext* /*context*/, const ::containers::WaitRequest* /*request*/, ::containers::WaitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWait(::grpc::ServerContext* context, ::containers::WaitRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::WaitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Events() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* /*context*/, const ::containers::EventsRequest* /*request*/, ::grpc::ServerWriter< ::containers::Event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEvents(::grpc::ServerContext* context, ::containers::EventsRequest* request, ::grpc::ServerAsyncWriter< ::containers::Event>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(13, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Exec() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::containers::ExecRequest* /*request*/, ::containers::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExec(::grpc::ServerContext* context, ::containers::ExecRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::ExecResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoteExec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RemoteExec() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_RemoteExec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteExec(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteExecResponse, ::containers::RemoteExecRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoteExec(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::containers::RemoteExecResponse, ::containers::RemoteExecRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(15, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Version() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::containers::VersionRequest* /*request*/, ::containers::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::containers::VersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::VersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Info() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_Info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Info(::grpc::ServerContext* /*context*/, const ::containers::InfoRequest* /*request*/, ::containers::InfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInfo(::grpc::ServerContext* context, ::containers::InfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::InfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Update() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::containers::UpdateRequest* /*request*/, ::containers::UpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdate(::grpc::ServerContext* context, ::containers::UpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::UpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Attach() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::AttachResponse, ::containers::AttachRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAttach(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::containers::AttachResponse, ::containers::AttachRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(19, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Restart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Restart() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_Restart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Restart(::grpc::ServerContext* /*context*/, const ::containers::RestartRequest* /*request*/, ::containers::RestartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRestart(::grpc::ServerContext* context, ::containers::RestartRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::RestartResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Export : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Export() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_Export() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Export(::grpc::ServerContext* /*context*/, const ::containers::ExportRequest* /*request*/, ::containers::ExportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExport(::grpc::ServerContext* context, ::containers::ExportRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::ExportResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CopyFromContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CopyFromContainer() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_CopyFromContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyFromContainer(::grpc::ServerContext* /*context*/, const ::containers::CopyFromContainerRequest* /*request*/, ::grpc::ServerWriter< ::containers::CopyFromContainerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCopyFromContainer(::grpc::ServerContext* context, ::containers::CopyFromContainerRequest* request, ::grpc::ServerAsyncWriter< ::containers::CopyFromContainerResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CopyToContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CopyToContainer() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_CopyToContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyToContainer(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::CopyToContainerResponse, ::containers::CopyToContainerRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCopyToContainer(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::containers::CopyToContainerResponse, ::containers::CopyToContainerRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(23, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Rename() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::containers::RenameRequest* /*request*/, ::containers::RenameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRename(::grpc::ServerContext* context, ::containers::RenameRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::RenameResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Logs() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logs(::grpc::ServerContext* /*context*/, const ::containers::LogsRequest* /*request*/, ::grpc::ServerWriter< ::containers::LogsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogs(::grpc::ServerContext* context, ::containers::LogsRequest* request, ::grpc::ServerAsyncWriter< ::containers::LogsResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(25, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Resize() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_Resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resize(::grpc::ServerContext* /*context*/, const ::containers::ResizeRequest* /*request*/, ::containers::ResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResize(::grpc::ServerContext* context, ::containers::ResizeRequest* request, ::grpc::ServerAsyncResponseWriter< ::containers::ResizeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Create<WithAsyncMethod_Start<WithAsyncMethod_RemoteStart<WithAsyncMethod_Top<WithAsyncMethod_Stop<WithAsyncMethod_Kill<WithAsyncMethod_Delete<WithAsyncMethod_Pause<WithAsyncMethod_Resume<WithAsyncMethod_Inspect<WithAsyncMethod_List<WithAsyncMethod_Stats<WithAsyncMethod_Wait<WithAsyncMethod_Events<WithAsyncMethod_Exec<WithAsyncMethod_RemoteExec<WithAsyncMethod_Version<WithAsyncMethod_Info<WithAsyncMethod_Update<WithAsyncMethod_Attach<WithAsyncMethod_Restart<WithAsyncMethod_Export<WithAsyncMethod_CopyFromContainer<WithAsyncMethod_CopyToContainer<WithAsyncMethod_Rename<WithAsyncMethod_Logs<WithAsyncMethod_Resize<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Create() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::CreateRequest, ::containers::CreateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::CreateRequest* request, ::containers::CreateResponse* response) { return this->Create(context, request, response); }));}
    void SetMessageAllocatorFor_Create(
        ::grpc::experimental::MessageAllocator< ::containers::CreateRequest, ::containers::CreateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::CreateRequest, ::containers::CreateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::containers::CreateRequest* /*request*/, ::containers::CreateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Create(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::CreateRequest* /*request*/, ::containers::CreateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Create(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::CreateRequest* /*request*/, ::containers::CreateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Start() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::StartRequest, ::containers::StartResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::StartRequest* request, ::containers::StartResponse* response) { return this->Start(context, request, response); }));}
    void SetMessageAllocatorFor_Start(
        ::grpc::experimental::MessageAllocator< ::containers::StartRequest, ::containers::StartResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::StartRequest, ::containers::StartResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::containers::StartRequest* /*request*/, ::containers::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Start(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::StartRequest* /*request*/, ::containers::StartResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Start(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::StartRequest* /*request*/, ::containers::StartResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoteStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoteStart() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackBidiHandler< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->RemoteStart(context); }));
    }
    ~ExperimentalWithCallbackMethod_RemoteStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteStart(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteStartResponse, ::containers::RemoteStartRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>* RemoteStart(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::containers::RemoteStartRequest, ::containers::RemoteStartResponse>* RemoteStart(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Top : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Top() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::TopRequest, ::containers::TopResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::TopRequest* request, ::containers::TopResponse* response) { return this->Top(context, request, response); }));}
    void SetMessageAllocatorFor_Top(
        ::grpc::experimental::MessageAllocator< ::containers::TopRequest, ::containers::TopResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::TopRequest, ::containers::TopResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Top() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Top(::grpc::ServerContext* /*context*/, const ::containers::TopRequest* /*request*/, ::containers::TopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Top(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::TopRequest* /*request*/, ::containers::TopResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Top(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::TopRequest* /*request*/, ::containers::TopResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Stop() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::StopRequest, ::containers::StopResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::StopRequest* request, ::containers::StopResponse* response) { return this->Stop(context, request, response); }));}
    void SetMessageAllocatorFor_Stop(
        ::grpc::experimental::MessageAllocator< ::containers::StopRequest, ::containers::StopResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::StopRequest, ::containers::StopResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::containers::StopRequest* /*request*/, ::containers::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Stop(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::StopRequest* /*request*/, ::containers::StopResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Stop(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::StopRequest* /*request*/, ::containers::StopResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Kill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Kill() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::KillRequest, ::containers::KillResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::KillRequest* request, ::containers::KillResponse* response) { return this->Kill(context, request, response); }));}
    void SetMessageAllocatorFor_Kill(
        ::grpc::experimental::MessageAllocator< ::containers::KillRequest, ::containers::KillResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::KillRequest, ::containers::KillResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Kill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Kill(::grpc::ServerContext* /*context*/, const ::containers::KillRequest* /*request*/, ::containers::KillResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Kill(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::KillRequest* /*request*/, ::containers::KillResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Kill(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::KillRequest* /*request*/, ::containers::KillResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Delete() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::DeleteRequest, ::containers::DeleteResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::DeleteRequest* request, ::containers::DeleteResponse* response) { return this->Delete(context, request, response); }));}
    void SetMessageAllocatorFor_Delete(
        ::grpc::experimental::MessageAllocator< ::containers::DeleteRequest, ::containers::DeleteResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::DeleteRequest, ::containers::DeleteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::containers::DeleteRequest* /*request*/, ::containers::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Delete(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::DeleteRequest* /*request*/, ::containers::DeleteResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Delete(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::DeleteRequest* /*request*/, ::containers::DeleteResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Pause() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::PauseRequest, ::containers::PauseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::PauseRequest* request, ::containers::PauseResponse* response) { return this->Pause(context, request, response); }));}
    void SetMessageAllocatorFor_Pause(
        ::grpc::experimental::MessageAllocator< ::containers::PauseRequest, ::containers::PauseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::PauseRequest, ::containers::PauseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::containers::PauseRequest* /*request*/, ::containers::PauseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Pause(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::PauseRequest* /*request*/, ::containers::PauseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Pause(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::PauseRequest* /*request*/, ::containers::PauseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Resume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::ResumeRequest, ::containers::ResumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::ResumeRequest* request, ::containers::ResumeResponse* response) { return this->Resume(context, request, response); }));}
    void SetMessageAllocatorFor_Resume(
        ::grpc::experimental::MessageAllocator< ::containers::ResumeRequest, ::containers::ResumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::ResumeRequest, ::containers::ResumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::containers::ResumeRequest* /*request*/, ::containers::ResumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Resume(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::ResumeRequest* /*request*/, ::containers::ResumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Resume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::ResumeRequest* /*request*/, ::containers::ResumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Inspect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Inspect() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::InspectContainerRequest, ::containers::InspectContainerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::InspectContainerRequest* request, ::containers::InspectContainerResponse* response) { return this->Inspect(context, request, response); }));}
    void SetMessageAllocatorFor_Inspect(
        ::grpc::experimental::MessageAllocator< ::containers::InspectContainerRequest, ::containers::InspectContainerResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::InspectContainerRequest, ::containers::InspectContainerResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Inspect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Inspect(::grpc::ServerContext* /*context*/, const ::containers::InspectContainerRequest* /*request*/, ::containers::InspectContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Inspect(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::InspectContainerRequest* /*request*/, ::containers::InspectContainerResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Inspect(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::InspectContainerRequest* /*request*/, ::containers::InspectContainerResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_List() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::ListRequest, ::containers::ListResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::ListRequest* request, ::containers::ListResponse* response) { return this->List(context, request, response); }));}
    void SetMessageAllocatorFor_List(
        ::grpc::experimental::MessageAllocator< ::containers::ListRequest, ::containers::ListResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::ListRequest, ::containers::ListResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::containers::ListRequest* /*request*/, ::containers::ListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* List(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::ListRequest* /*request*/, ::containers::ListResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* List(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::ListRequest* /*request*/, ::containers::ListResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Stats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Stats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::StatsRequest, ::containers::StatsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::StatsRequest* request, ::containers::StatsResponse* response) { return this->Stats(context, request, response); }));}
    void SetMessageAllocatorFor_Stats(
        ::grpc::experimental::MessageAllocator< ::containers::StatsRequest, ::containers::StatsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::StatsRequest, ::containers::StatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Stats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stats(::grpc::ServerContext* /*context*/, const ::containers::StatsRequest* /*request*/, ::containers::StatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Stats(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::StatsRequest* /*request*/, ::containers::StatsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Stats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::StatsRequest* /*request*/, ::containers::StatsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Wait() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::WaitRequest, ::containers::WaitResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::WaitRequest* request, ::containers::WaitResponse* response) { return this->Wait(context, request, response); }));}
    void SetMessageAllocatorFor_Wait(
        ::grpc::experimental::MessageAllocator< ::containers::WaitRequest, ::containers::WaitResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::WaitRequest, ::containers::WaitResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Wait(::grpc::ServerContext* /*context*/, const ::containers::WaitRequest* /*request*/, ::containers::WaitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Wait(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::WaitRequest* /*request*/, ::containers::WaitResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Wait(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::WaitRequest* /*request*/, ::containers::WaitResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Events() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::containers::EventsRequest, ::containers::Event>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::EventsRequest* request) { return this->Events(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* /*context*/, const ::containers::EventsRequest* /*request*/, ::grpc::ServerWriter< ::containers::Event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::containers::Event>* Events(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::EventsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::containers::Event>* Events(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::EventsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Exec() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::ExecRequest, ::containers::ExecResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::ExecRequest* request, ::containers::ExecResponse* response) { return this->Exec(context, request, response); }));}
    void SetMessageAllocatorFor_Exec(
        ::grpc::experimental::MessageAllocator< ::containers::ExecRequest, ::containers::ExecResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::ExecRequest, ::containers::ExecResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::containers::ExecRequest* /*request*/, ::containers::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Exec(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::ExecRequest* /*request*/, ::containers::ExecResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Exec(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::ExecRequest* /*request*/, ::containers::ExecResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RemoteExec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RemoteExec() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc_impl::internal::CallbackBidiHandler< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->RemoteExec(context); }));
    }
    ~ExperimentalWithCallbackMethod_RemoteExec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteExec(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteExecResponse, ::containers::RemoteExecRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>* RemoteExec(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::containers::RemoteExecRequest, ::containers::RemoteExecResponse>* RemoteExec(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Version() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::VersionRequest, ::containers::VersionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::VersionRequest* request, ::containers::VersionResponse* response) { return this->Version(context, request, response); }));}
    void SetMessageAllocatorFor_Version(
        ::grpc::experimental::MessageAllocator< ::containers::VersionRequest, ::containers::VersionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::VersionRequest, ::containers::VersionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::containers::VersionRequest* /*request*/, ::containers::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Version(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::VersionRequest* /*request*/, ::containers::VersionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Version(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::VersionRequest* /*request*/, ::containers::VersionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Info() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::InfoRequest, ::containers::InfoResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::InfoRequest* request, ::containers::InfoResponse* response) { return this->Info(context, request, response); }));}
    void SetMessageAllocatorFor_Info(
        ::grpc::experimental::MessageAllocator< ::containers::InfoRequest, ::containers::InfoResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::InfoRequest, ::containers::InfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Info(::grpc::ServerContext* /*context*/, const ::containers::InfoRequest* /*request*/, ::containers::InfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Info(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::InfoRequest* /*request*/, ::containers::InfoResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Info(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::InfoRequest* /*request*/, ::containers::InfoResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Update() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::UpdateRequest, ::containers::UpdateResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::UpdateRequest* request, ::containers::UpdateResponse* response) { return this->Update(context, request, response); }));}
    void SetMessageAllocatorFor_Update(
        ::grpc::experimental::MessageAllocator< ::containers::UpdateRequest, ::containers::UpdateResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::UpdateRequest, ::containers::UpdateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::containers::UpdateRequest* /*request*/, ::containers::UpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Update(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::UpdateRequest* /*request*/, ::containers::UpdateResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Update(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::UpdateRequest* /*request*/, ::containers::UpdateResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Attach() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc_impl::internal::CallbackBidiHandler< ::containers::AttachRequest, ::containers::AttachResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->Attach(context); }));
    }
    ~ExperimentalWithCallbackMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::AttachResponse, ::containers::AttachRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::containers::AttachRequest, ::containers::AttachResponse>* Attach(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::containers::AttachRequest, ::containers::AttachResponse>* Attach(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Restart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Restart() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::RestartRequest, ::containers::RestartResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::RestartRequest* request, ::containers::RestartResponse* response) { return this->Restart(context, request, response); }));}
    void SetMessageAllocatorFor_Restart(
        ::grpc::experimental::MessageAllocator< ::containers::RestartRequest, ::containers::RestartResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::RestartRequest, ::containers::RestartResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Restart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Restart(::grpc::ServerContext* /*context*/, const ::containers::RestartRequest* /*request*/, ::containers::RestartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Restart(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::RestartRequest* /*request*/, ::containers::RestartResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Restart(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::RestartRequest* /*request*/, ::containers::RestartResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Export : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Export() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::ExportRequest, ::containers::ExportResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::ExportRequest* request, ::containers::ExportResponse* response) { return this->Export(context, request, response); }));}
    void SetMessageAllocatorFor_Export(
        ::grpc::experimental::MessageAllocator< ::containers::ExportRequest, ::containers::ExportResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::ExportRequest, ::containers::ExportResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Export() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Export(::grpc::ServerContext* /*context*/, const ::containers::ExportRequest* /*request*/, ::containers::ExportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Export(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::ExportRequest* /*request*/, ::containers::ExportResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Export(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::ExportRequest* /*request*/, ::containers::ExportResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CopyFromContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CopyFromContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::containers::CopyFromContainerRequest, ::containers::CopyFromContainerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::CopyFromContainerRequest* request) { return this->CopyFromContainer(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_CopyFromContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyFromContainer(::grpc::ServerContext* /*context*/, const ::containers::CopyFromContainerRequest* /*request*/, ::grpc::ServerWriter< ::containers::CopyFromContainerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::containers::CopyFromContainerResponse>* CopyFromContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::CopyFromContainerRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::containers::CopyFromContainerResponse>* CopyFromContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::CopyFromContainerRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CopyToContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CopyToContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc_impl::internal::CallbackBidiHandler< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->CopyToContainer(context); }));
    }
    ~ExperimentalWithCallbackMethod_CopyToContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyToContainer(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::CopyToContainerResponse, ::containers::CopyToContainerRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>* CopyToContainer(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::containers::CopyToContainerRequest, ::containers::CopyToContainerResponse>* CopyToContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Rename() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::RenameRequest, ::containers::RenameResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::RenameRequest* request, ::containers::RenameResponse* response) { return this->Rename(context, request, response); }));}
    void SetMessageAllocatorFor_Rename(
        ::grpc::experimental::MessageAllocator< ::containers::RenameRequest, ::containers::RenameResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(24);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::RenameRequest, ::containers::RenameResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::containers::RenameRequest* /*request*/, ::containers::RenameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Rename(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::RenameRequest* /*request*/, ::containers::RenameResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Rename(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::RenameRequest* /*request*/, ::containers::RenameResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Logs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::containers::LogsRequest, ::containers::LogsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::LogsRequest* request) { return this->Logs(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logs(::grpc::ServerContext* /*context*/, const ::containers::LogsRequest* /*request*/, ::grpc::ServerWriter< ::containers::LogsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::containers::LogsResponse>* Logs(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::LogsRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::containers::LogsResponse>* Logs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::LogsRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Resize() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::containers::ResizeRequest, ::containers::ResizeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::containers::ResizeRequest* request, ::containers::ResizeResponse* response) { return this->Resize(context, request, response); }));}
    void SetMessageAllocatorFor_Resize(
        ::grpc::experimental::MessageAllocator< ::containers::ResizeRequest, ::containers::ResizeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::containers::ResizeRequest, ::containers::ResizeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resize(::grpc::ServerContext* /*context*/, const ::containers::ResizeRequest* /*request*/, ::containers::ResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Resize(
      ::grpc::CallbackServerContext* /*context*/, const ::containers::ResizeRequest* /*request*/, ::containers::ResizeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Resize(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::containers::ResizeRequest* /*request*/, ::containers::ResizeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Create<ExperimentalWithCallbackMethod_Start<ExperimentalWithCallbackMethod_RemoteStart<ExperimentalWithCallbackMethod_Top<ExperimentalWithCallbackMethod_Stop<ExperimentalWithCallbackMethod_Kill<ExperimentalWithCallbackMethod_Delete<ExperimentalWithCallbackMethod_Pause<ExperimentalWithCallbackMethod_Resume<ExperimentalWithCallbackMethod_Inspect<ExperimentalWithCallbackMethod_List<ExperimentalWithCallbackMethod_Stats<ExperimentalWithCallbackMethod_Wait<ExperimentalWithCallbackMethod_Events<ExperimentalWithCallbackMethod_Exec<ExperimentalWithCallbackMethod_RemoteExec<ExperimentalWithCallbackMethod_Version<ExperimentalWithCallbackMethod_Info<ExperimentalWithCallbackMethod_Update<ExperimentalWithCallbackMethod_Attach<ExperimentalWithCallbackMethod_Restart<ExperimentalWithCallbackMethod_Export<ExperimentalWithCallbackMethod_CopyFromContainer<ExperimentalWithCallbackMethod_CopyToContainer<ExperimentalWithCallbackMethod_Rename<ExperimentalWithCallbackMethod_Logs<ExperimentalWithCallbackMethod_Resize<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Create<ExperimentalWithCallbackMethod_Start<ExperimentalWithCallbackMethod_RemoteStart<ExperimentalWithCallbackMethod_Top<ExperimentalWithCallbackMethod_Stop<ExperimentalWithCallbackMethod_Kill<ExperimentalWithCallbackMethod_Delete<ExperimentalWithCallbackMethod_Pause<ExperimentalWithCallbackMethod_Resume<ExperimentalWithCallbackMethod_Inspect<ExperimentalWithCallbackMethod_List<ExperimentalWithCallbackMethod_Stats<ExperimentalWithCallbackMethod_Wait<ExperimentalWithCallbackMethod_Events<ExperimentalWithCallbackMethod_Exec<ExperimentalWithCallbackMethod_RemoteExec<ExperimentalWithCallbackMethod_Version<ExperimentalWithCallbackMethod_Info<ExperimentalWithCallbackMethod_Update<ExperimentalWithCallbackMethod_Attach<ExperimentalWithCallbackMethod_Restart<ExperimentalWithCallbackMethod_Export<ExperimentalWithCallbackMethod_CopyFromContainer<ExperimentalWithCallbackMethod_CopyToContainer<ExperimentalWithCallbackMethod_Rename<ExperimentalWithCallbackMethod_Logs<ExperimentalWithCallbackMethod_Resize<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Create() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::containers::CreateRequest* /*request*/, ::containers::CreateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Start() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::containers::StartRequest* /*request*/, ::containers::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoteStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoteStart() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_RemoteStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteStart(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteStartResponse, ::containers::RemoteStartRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Top : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Top() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Top() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Top(::grpc::ServerContext* /*context*/, const ::containers::TopRequest* /*request*/, ::containers::TopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Stop() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::containers::StopRequest* /*request*/, ::containers::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Kill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Kill() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Kill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Kill(::grpc::ServerContext* /*context*/, const ::containers::KillRequest* /*request*/, ::containers::KillResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Delete() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::containers::DeleteRequest* /*request*/, ::containers::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Pause() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::containers::PauseRequest* /*request*/, ::containers::PauseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Resume() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::containers::ResumeRequest* /*request*/, ::containers::ResumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Inspect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Inspect() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_Inspect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Inspect(::grpc::ServerContext* /*context*/, const ::containers::InspectContainerRequest* /*request*/, ::containers::InspectContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_List() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::containers::ListRequest* /*request*/, ::containers::ListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Stats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Stats() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_Stats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stats(::grpc::ServerContext* /*context*/, const ::containers::StatsRequest* /*request*/, ::containers::StatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Wait() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_Wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Wait(::grpc::ServerContext* /*context*/, const ::containers::WaitRequest* /*request*/, ::containers::WaitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Events() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* /*context*/, const ::containers::EventsRequest* /*request*/, ::grpc::ServerWriter< ::containers::Event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Exec() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::containers::ExecRequest* /*request*/, ::containers::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoteExec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RemoteExec() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_RemoteExec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteExec(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteExecResponse, ::containers::RemoteExecRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Version() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::containers::VersionRequest* /*request*/, ::containers::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Info() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_Info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Info(::grpc::ServerContext* /*context*/, const ::containers::InfoRequest* /*request*/, ::containers::InfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Update() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::containers::UpdateRequest* /*request*/, ::containers::UpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Attach() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::AttachResponse, ::containers::AttachRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Restart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Restart() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_Restart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Restart(::grpc::ServerContext* /*context*/, const ::containers::RestartRequest* /*request*/, ::containers::RestartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Export : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Export() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_Export() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Export(::grpc::ServerContext* /*context*/, const ::containers::ExportRequest* /*request*/, ::containers::ExportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CopyFromContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CopyFromContainer() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_CopyFromContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyFromContainer(::grpc::ServerContext* /*context*/, const ::containers::CopyFromContainerRequest* /*request*/, ::grpc::ServerWriter< ::containers::CopyFromContainerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CopyToContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CopyToContainer() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_CopyToContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyToContainer(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::CopyToContainerResponse, ::containers::CopyToContainerRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Rename() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::containers::RenameRequest* /*request*/, ::containers::RenameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Logs() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logs(::grpc::ServerContext* /*context*/, const ::containers::LogsRequest* /*request*/, ::grpc::ServerWriter< ::containers::LogsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Resize() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_Resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resize(::grpc::ServerContext* /*context*/, const ::containers::ResizeRequest* /*request*/, ::containers::ResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Create() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::containers::CreateRequest* /*request*/, ::containers::CreateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Start() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::containers::StartRequest* /*request*/, ::containers::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoteStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoteStart() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_RemoteStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteStart(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteStartResponse, ::containers::RemoteStartRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoteStart(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Top : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Top() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Top() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Top(::grpc::ServerContext* /*context*/, const ::containers::TopRequest* /*request*/, ::containers::TopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Stop() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::containers::StopRequest* /*request*/, ::containers::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStop(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Kill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Kill() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Kill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Kill(::grpc::ServerContext* /*context*/, const ::containers::KillRequest* /*request*/, ::containers::KillResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKill(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Delete() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::containers::DeleteRequest* /*request*/, ::containers::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Pause() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::containers::PauseRequest* /*request*/, ::containers::PauseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPause(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Resume() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::containers::ResumeRequest* /*request*/, ::containers::ResumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Inspect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Inspect() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_Inspect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Inspect(::grpc::ServerContext* /*context*/, const ::containers::InspectContainerRequest* /*request*/, ::containers::InspectContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInspect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_List() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::containers::ListRequest* /*request*/, ::containers::ListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Stats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Stats() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_Stats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stats(::grpc::ServerContext* /*context*/, const ::containers::StatsRequest* /*request*/, ::containers::StatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Wait() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_Wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Wait(::grpc::ServerContext* /*context*/, const ::containers::WaitRequest* /*request*/, ::containers::WaitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWait(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Events() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* /*context*/, const ::containers::EventsRequest* /*request*/, ::grpc::ServerWriter< ::containers::Event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEvents(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(13, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Exec() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::containers::ExecRequest* /*request*/, ::containers::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExec(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoteExec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RemoteExec() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_RemoteExec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteExec(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteExecResponse, ::containers::RemoteExecRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoteExec(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(15, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Version() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::containers::VersionRequest* /*request*/, ::containers::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Info() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_Info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Info(::grpc::ServerContext* /*context*/, const ::containers::InfoRequest* /*request*/, ::containers::InfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Update() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::containers::UpdateRequest* /*request*/, ::containers::UpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Attach() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::AttachResponse, ::containers::AttachRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAttach(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(19, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Restart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Restart() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_Restart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Restart(::grpc::ServerContext* /*context*/, const ::containers::RestartRequest* /*request*/, ::containers::RestartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRestart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Export : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Export() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_Export() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Export(::grpc::ServerContext* /*context*/, const ::containers::ExportRequest* /*request*/, ::containers::ExportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExport(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CopyFromContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CopyFromContainer() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_CopyFromContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyFromContainer(::grpc::ServerContext* /*context*/, const ::containers::CopyFromContainerRequest* /*request*/, ::grpc::ServerWriter< ::containers::CopyFromContainerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCopyFromContainer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(22, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CopyToContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CopyToContainer() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_CopyToContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyToContainer(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::CopyToContainerResponse, ::containers::CopyToContainerRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCopyToContainer(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(23, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Rename() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::containers::RenameRequest* /*request*/, ::containers::RenameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRename(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Logs() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logs(::grpc::ServerContext* /*context*/, const ::containers::LogsRequest* /*request*/, ::grpc::ServerWriter< ::containers::LogsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(25, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Resize() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_Resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resize(::grpc::ServerContext* /*context*/, const ::containers::ResizeRequest* /*request*/, ::containers::ResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Create() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Create(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::containers::CreateRequest* /*request*/, ::containers::CreateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Create(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Create(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Start() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Start(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::containers::StartRequest* /*request*/, ::containers::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Start(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Start(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoteStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoteStart() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->RemoteStart(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoteStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteStart(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteStartResponse, ::containers::RemoteStartRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* RemoteStart(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* RemoteStart(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Top : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Top() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Top(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Top() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Top(::grpc::ServerContext* /*context*/, const ::containers::TopRequest* /*request*/, ::containers::TopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Top(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Top(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Stop() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Stop(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::containers::StopRequest* /*request*/, ::containers::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Stop(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Stop(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Kill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Kill() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Kill(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Kill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Kill(::grpc::ServerContext* /*context*/, const ::containers::KillRequest* /*request*/, ::containers::KillResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Kill(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Kill(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Delete() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Delete(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::containers::DeleteRequest* /*request*/, ::containers::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Delete(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Delete(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Pause() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Pause(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::containers::PauseRequest* /*request*/, ::containers::PauseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Pause(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Pause(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Resume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Resume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::containers::ResumeRequest* /*request*/, ::containers::ResumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Resume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Resume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Inspect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Inspect() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Inspect(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Inspect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Inspect(::grpc::ServerContext* /*context*/, const ::containers::InspectContainerRequest* /*request*/, ::containers::InspectContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Inspect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Inspect(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_List() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->List(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::containers::ListRequest* /*request*/, ::containers::ListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* List(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* List(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Stats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Stats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Stats(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Stats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Stats(::grpc::ServerContext* /*context*/, const ::containers::StatsRequest* /*request*/, ::containers::StatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Stats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Stats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Wait() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Wait(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Wait(::grpc::ServerContext* /*context*/, const ::containers::WaitRequest* /*request*/, ::containers::WaitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Wait(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Wait(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Events() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->Events(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Events(::grpc::ServerContext* /*context*/, const ::containers::EventsRequest* /*request*/, ::grpc::ServerWriter< ::containers::Event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Events(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* Events(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Exec() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Exec(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::containers::ExecRequest* /*request*/, ::containers::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Exec(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Exec(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RemoteExec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RemoteExec() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->RemoteExec(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_RemoteExec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoteExec(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::RemoteExecResponse, ::containers::RemoteExecRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* RemoteExec(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* RemoteExec(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Version() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Version(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::containers::VersionRequest* /*request*/, ::containers::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Version(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Version(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Info() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Info(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Info(::grpc::ServerContext* /*context*/, const ::containers::InfoRequest* /*request*/, ::containers::InfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Info(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Update() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Update(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::containers::UpdateRequest* /*request*/, ::containers::UpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Update(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Update(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Attach : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Attach() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->Attach(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_Attach() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Attach(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::AttachResponse, ::containers::AttachRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Attach(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Attach(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Restart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Restart() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Restart(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Restart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Restart(::grpc::ServerContext* /*context*/, const ::containers::RestartRequest* /*request*/, ::containers::RestartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Restart(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Restart(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Export : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Export() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Export(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Export() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Export(::grpc::ServerContext* /*context*/, const ::containers::ExportRequest* /*request*/, ::containers::ExportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Export(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Export(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CopyFromContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CopyFromContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->CopyFromContainer(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_CopyFromContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyFromContainer(::grpc::ServerContext* /*context*/, const ::containers::CopyFromContainerRequest* /*request*/, ::grpc::ServerWriter< ::containers::CopyFromContainerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* CopyFromContainer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* CopyFromContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CopyToContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CopyToContainer() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context) { return this->CopyToContainer(context); }));
    }
    ~ExperimentalWithRawCallbackMethod_CopyToContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CopyToContainer(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::containers::CopyToContainerResponse, ::containers::CopyToContainerRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* CopyToContainer(
      ::grpc::CallbackServerContext* /*context*/)
    #else
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* CopyToContainer(
      ::grpc::experimental::CallbackServerContext* /*context*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Rename() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Rename(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::containers::RenameRequest* /*request*/, ::containers::RenameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Rename(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Rename(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Logs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->Logs(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Logs(::grpc::ServerContext* /*context*/, const ::containers::LogsRequest* /*request*/, ::grpc::ServerWriter< ::containers::LogsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Logs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* Logs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Resize() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Resize(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Resize(::grpc::ServerContext* /*context*/, const ::containers::ResizeRequest* /*request*/, ::containers::ResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Resize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Resize(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Create() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::CreateRequest, ::containers::CreateResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::CreateRequest, ::containers::CreateResponse>* streamer) {
                       return this->StreamedCreate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::containers::CreateRequest* /*request*/, ::containers::CreateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::CreateRequest,::containers::CreateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Start : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Start() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::StartRequest, ::containers::StartResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::StartRequest, ::containers::StartResponse>* streamer) {
                       return this->StreamedStart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Start() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Start(::grpc::ServerContext* /*context*/, const ::containers::StartRequest* /*request*/, ::containers::StartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::StartRequest,::containers::StartResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Top : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Top() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::TopRequest, ::containers::TopResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::TopRequest, ::containers::TopResponse>* streamer) {
                       return this->StreamedTop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Top() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Top(::grpc::ServerContext* /*context*/, const ::containers::TopRequest* /*request*/, ::containers::TopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::TopRequest,::containers::TopResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Stop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Stop() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::StopRequest, ::containers::StopResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::StopRequest, ::containers::StopResponse>* streamer) {
                       return this->StreamedStop(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Stop() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Stop(::grpc::ServerContext* /*context*/, const ::containers::StopRequest* /*request*/, ::containers::StopResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStop(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::StopRequest,::containers::StopResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Kill : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Kill() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::KillRequest, ::containers::KillResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::KillRequest, ::containers::KillResponse>* streamer) {
                       return this->StreamedKill(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Kill() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Kill(::grpc::ServerContext* /*context*/, const ::containers::KillRequest* /*request*/, ::containers::KillResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKill(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::KillRequest,::containers::KillResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Delete() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::DeleteRequest, ::containers::DeleteResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::DeleteRequest, ::containers::DeleteResponse>* streamer) {
                       return this->StreamedDelete(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::containers::DeleteRequest* /*request*/, ::containers::DeleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDelete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::DeleteRequest,::containers::DeleteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Pause : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Pause() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::PauseRequest, ::containers::PauseResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::PauseRequest, ::containers::PauseResponse>* streamer) {
                       return this->StreamedPause(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Pause() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Pause(::grpc::ServerContext* /*context*/, const ::containers::PauseRequest* /*request*/, ::containers::PauseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPause(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::PauseRequest,::containers::PauseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Resume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Resume() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::ResumeRequest, ::containers::ResumeResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::ResumeRequest, ::containers::ResumeResponse>* streamer) {
                       return this->StreamedResume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Resume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Resume(::grpc::ServerContext* /*context*/, const ::containers::ResumeRequest* /*request*/, ::containers::ResumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::ResumeRequest,::containers::ResumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Inspect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Inspect() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::InspectContainerRequest, ::containers::InspectContainerResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::InspectContainerRequest, ::containers::InspectContainerResponse>* streamer) {
                       return this->StreamedInspect(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Inspect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Inspect(::grpc::ServerContext* /*context*/, const ::containers::InspectContainerRequest* /*request*/, ::containers::InspectContainerResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInspect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::InspectContainerRequest,::containers::InspectContainerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_List : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_List() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::ListRequest, ::containers::ListResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::ListRequest, ::containers::ListResponse>* streamer) {
                       return this->StreamedList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_List() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status List(::grpc::ServerContext* /*context*/, const ::containers::ListRequest* /*request*/, ::containers::ListResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::ListRequest,::containers::ListResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Stats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Stats() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::StatsRequest, ::containers::StatsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::StatsRequest, ::containers::StatsResponse>* streamer) {
                       return this->StreamedStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Stats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Stats(::grpc::ServerContext* /*context*/, const ::containers::StatsRequest* /*request*/, ::containers::StatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::StatsRequest,::containers::StatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Wait() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::WaitRequest, ::containers::WaitResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::WaitRequest, ::containers::WaitResponse>* streamer) {
                       return this->StreamedWait(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Wait(::grpc::ServerContext* /*context*/, const ::containers::WaitRequest* /*request*/, ::containers::WaitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWait(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::WaitRequest,::containers::WaitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Exec : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Exec() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::ExecRequest, ::containers::ExecResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::ExecRequest, ::containers::ExecResponse>* streamer) {
                       return this->StreamedExec(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Exec() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Exec(::grpc::ServerContext* /*context*/, const ::containers::ExecRequest* /*request*/, ::containers::ExecResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExec(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::ExecRequest,::containers::ExecResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Version() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::VersionRequest, ::containers::VersionResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::VersionRequest, ::containers::VersionResponse>* streamer) {
                       return this->StreamedVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Version(::grpc::ServerContext* /*context*/, const ::containers::VersionRequest* /*request*/, ::containers::VersionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::VersionRequest,::containers::VersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Info() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::InfoRequest, ::containers::InfoResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::InfoRequest, ::containers::InfoResponse>* streamer) {
                       return this->StreamedInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Info(::grpc::ServerContext* /*context*/, const ::containers::InfoRequest* /*request*/, ::containers::InfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::InfoRequest,::containers::InfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Update() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::UpdateRequest, ::containers::UpdateResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::UpdateRequest, ::containers::UpdateResponse>* streamer) {
                       return this->StreamedUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::containers::UpdateRequest* /*request*/, ::containers::UpdateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::UpdateRequest,::containers::UpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Restart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Restart() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::RestartRequest, ::containers::RestartResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::RestartRequest, ::containers::RestartResponse>* streamer) {
                       return this->StreamedRestart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Restart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Restart(::grpc::ServerContext* /*context*/, const ::containers::RestartRequest* /*request*/, ::containers::RestartResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRestart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::RestartRequest,::containers::RestartResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Export : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Export() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::ExportRequest, ::containers::ExportResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::ExportRequest, ::containers::ExportResponse>* streamer) {
                       return this->StreamedExport(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Export() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Export(::grpc::ServerContext* /*context*/, const ::containers::ExportRequest* /*request*/, ::containers::ExportResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExport(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::ExportRequest,::containers::ExportResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Rename : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Rename() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::RenameRequest, ::containers::RenameResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::RenameRequest, ::containers::RenameResponse>* streamer) {
                       return this->StreamedRename(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Rename() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Rename(::grpc::ServerContext* /*context*/, const ::containers::RenameRequest* /*request*/, ::containers::RenameResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRename(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::RenameRequest,::containers::RenameResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Resize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Resize() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::containers::ResizeRequest, ::containers::ResizeResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::containers::ResizeRequest, ::containers::ResizeResponse>* streamer) {
                       return this->StreamedResize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Resize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Resize(::grpc::ServerContext* /*context*/, const ::containers::ResizeRequest* /*request*/, ::containers::ResizeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::containers::ResizeRequest,::containers::ResizeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Create<WithStreamedUnaryMethod_Start<WithStreamedUnaryMethod_Top<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_Kill<WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_Pause<WithStreamedUnaryMethod_Resume<WithStreamedUnaryMethod_Inspect<WithStreamedUnaryMethod_List<WithStreamedUnaryMethod_Stats<WithStreamedUnaryMethod_Wait<WithStreamedUnaryMethod_Exec<WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_Info<WithStreamedUnaryMethod_Update<WithStreamedUnaryMethod_Restart<WithStreamedUnaryMethod_Export<WithStreamedUnaryMethod_Rename<WithStreamedUnaryMethod_Resize<Service > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Events() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::containers::EventsRequest, ::containers::Event>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::containers::EventsRequest, ::containers::Event>* streamer) {
                       return this->StreamedEvents(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Events(::grpc::ServerContext* /*context*/, const ::containers::EventsRequest* /*request*/, ::grpc::ServerWriter< ::containers::Event>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedEvents(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::containers::EventsRequest,::containers::Event>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_CopyFromContainer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_CopyFromContainer() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::containers::CopyFromContainerRequest, ::containers::CopyFromContainerResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::containers::CopyFromContainerRequest, ::containers::CopyFromContainerResponse>* streamer) {
                       return this->StreamedCopyFromContainer(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_CopyFromContainer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CopyFromContainer(::grpc::ServerContext* /*context*/, const ::containers::CopyFromContainerRequest* /*request*/, ::grpc::ServerWriter< ::containers::CopyFromContainerResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedCopyFromContainer(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::containers::CopyFromContainerRequest,::containers::CopyFromContainerResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_Logs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Logs() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::containers::LogsRequest, ::containers::LogsResponse>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::containers::LogsRequest, ::containers::LogsResponse>* streamer) {
                       return this->StreamedLogs(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Logs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Logs(::grpc::ServerContext* /*context*/, const ::containers::LogsRequest* /*request*/, ::grpc::ServerWriter< ::containers::LogsResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedLogs(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::containers::LogsRequest,::containers::LogsResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Events<WithSplitStreamingMethod_CopyFromContainer<WithSplitStreamingMethod_Logs<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Create<WithStreamedUnaryMethod_Start<WithStreamedUnaryMethod_Top<WithStreamedUnaryMethod_Stop<WithStreamedUnaryMethod_Kill<WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_Pause<WithStreamedUnaryMethod_Resume<WithStreamedUnaryMethod_Inspect<WithStreamedUnaryMethod_List<WithStreamedUnaryMethod_Stats<WithStreamedUnaryMethod_Wait<WithSplitStreamingMethod_Events<WithStreamedUnaryMethod_Exec<WithStreamedUnaryMethod_Version<WithStreamedUnaryMethod_Info<WithStreamedUnaryMethod_Update<WithStreamedUnaryMethod_Restart<WithStreamedUnaryMethod_Export<WithSplitStreamingMethod_CopyFromContainer<WithStreamedUnaryMethod_Rename<WithSplitStreamingMethod_Logs<WithStreamedUnaryMethod_Resize<Service > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace containers


#endif  // GRPC_container_2eproto__INCLUDED
